#!/usr/bin/env bash
set -euo pipefail

# codex-pocket CLI
#
# This CLI manages the local Codex Pocket service (launchd) and calls its admin API.

APP_DIR="${CODEX_POCKET_HOME:-$HOME/.codex-pocket}"
CONFIG_JSON="$APP_DIR/config.json"
LABEL="com.codex.pocket"
PID_FILE="$APP_DIR/server.pid"

bold=$'\033[1m'
reset=$'\033[0m'

usage() {
  cat <<USAGE
Usage: codex-pocket <command>

Commands:
  doctor                 Check dependencies and service health
  start                  Start the launchd service
  stop                   Stop the launchd service
  restart                Restart the service
  ensure                 Validate and attempt safe auto-repair
  smoke-test             Run a fast PASS/FAIL check against the local service
  summary                Print current config + URLs + log locations
  status                 Show admin status JSON
  logs [anchor]          Tail logs (default: anchor)
  pair                   Create a one-time pairing link (prints URL)
  token                  Print the Access Token (from config)
  urls                   Print local/admin/tailnet URLs (from config)
  diagnose               Run a diagnostic report for troubleshooting
  open-admin             Open the local Admin page in your browser
  update                 Update the installed app (git pull, rebuild, restart, ensure)
  summary                Print current config + URLs + log locations

Environment:
  CODEX_POCKET_HOME       Defaults to ~/.codex-pocket
USAGE
}

need_cmd() {
  command -v "$1" >/dev/null 2>&1 || { echo "Missing dependency: $1" >&2; exit 1; }
}

resolve_tailscale() {
  if command -v tailscale >/dev/null 2>&1; then
    command -v tailscale
    return 0
  fi
  # Tailscale's macOS GUI app bundles a CLI at this path.
  if [[ -x "/Applications/Tailscale.app/Contents/MacOS/Tailscale" ]]; then
    echo "/Applications/Tailscale.app/Contents/MacOS/Tailscale"
    return 0
  fi
  if [[ -x "/opt/homebrew/bin/tailscale" ]]; then
    echo "/opt/homebrew/bin/tailscale"
    return 0
  fi
  if [[ -x "/usr/local/bin/tailscale" ]]; then
    echo "/usr/local/bin/tailscale"
    return 0
  fi
  return 1
}

resolve_bun() {
  if command -v bun >/dev/null 2>&1; then
    command -v bun
    return 0
  fi
  if [[ -x "$HOME/.bun/bin/bun" ]]; then
    echo "$HOME/.bun/bin/bun"
    return 0
  fi
  if [[ -x "/opt/homebrew/bin/bun" ]]; then
    echo "/opt/homebrew/bin/bun"
    return 0
  fi
  return 1
}

read_config() {
  [[ -f "$CONFIG_JSON" ]] || { echo "Missing config: $CONFIG_JSON" >&2; exit 1; }
}

config_host() {
  python3 - "$CONFIG_JSON" <<'PY'
import json,sys
with open(sys.argv[1]) as f:
  d=json.load(f)
print(d.get('host','127.0.0.1'))
PY
}

config_port() {
  python3 - "$CONFIG_JSON" <<'PY'
import json,sys
with open(sys.argv[1]) as f:
  d=json.load(f)
print(int(d.get('port',8790)))
PY
}

base_url() {
  python3 - "$CONFIG_JSON" <<'PY'
import json,sys
with open(sys.argv[1]) as f:
  d=json.load(f)
print(f"http://{d.get('host','127.0.0.1')}:{d.get('port',8790)}")
PY
}

token() {
  python3 - "$CONFIG_JSON" <<'PY'
import json,sys
with open(sys.argv[1]) as f:
  d=json.load(f)
print(d.get('token',''))
PY
}

public_origin() {
  python3 - "$CONFIG_JSON" <<'PY'
import json,sys
with open(sys.argv[1]) as f:
  d=json.load(f)
print(d.get('publicOrigin',''))
PY
}

anchor_port() {
  python3 - "$CONFIG_JSON" <<'PY'
import json,sys
with open(sys.argv[1]) as f:
  d=json.load(f)
print(((d.get("anchor") or {}).get("port")) or 8788)
PY
}

db_path() {
  python3 - "$CONFIG_JSON" <<'PY'
import json,sys
with open(sys.argv[1]) as f:
  d=json.load(f)
print(d.get("db",""))
PY
}

retention_days() {
  python3 - "$CONFIG_JSON" <<'PY'
import json,sys
with open(sys.argv[1]) as f:
  d=json.load(f)
print(d.get("retentionDays",14))
PY
}

curl_auth() {
  local url="$1"; shift
  local tok
  tok="$(token)"
  curl -fsS -H "Authorization: Bearer $tok" "$url" "$@"
}

curl_auth_soft() {
  # Like curl_auth, but does not use `-f` so callers can inspect 401/500 bodies.
  local url="$1"; shift
  local tok
  tok="$(token)"
  curl -sS -H "Authorization: Bearer $tok" "$url" "$@"
}

curl_auth_soft_with_code() {
  # Prints "<http_code>\n<body>" (body may be empty).
  local url="$1"; shift
  local tok
  tok="$(token)"
  local resp
  resp="$(curl -sS -w $'\n__CODE__%{http_code}' -H "Authorization: Bearer $tok" "$url" "$@" || true)"
  local code="${resp##*$'\n__CODE__'}"
  local body="${resp%$'\n__CODE__'*}"
  printf '%s\n%s' "$code" "$body"
}

split_code_body() {
  # Reads "<http_code>\n<body>" from stdin and sets CODE/BODY globals.
  local first rest
  IFS= read -r first || true
  rest="$(cat || true)"
  CODE="$(printf '%s' "$first" | tr -d '\r')"
  BODY="$rest"
}

json_ok() {
  # Exit 0 if stdin is valid JSON with {"ok": true}, else exit non-zero.
  # Never prints a Python traceback (keeps CLI output user-friendly).
  python3 - <<'PY'
import json,sys
raw=sys.stdin.read()
try:
  d=json.loads(raw)
except Exception:
  sys.exit(3)
sys.exit(0 if d.get("ok") else 2)
PY
}

json_compact_failures() {
  # Prints failing checks (if present) from a validate JSON body, else nothing.
  python3 - <<'PY'
import json,sys
raw=sys.stdin.read()
try:
  d=json.loads(raw)
except Exception:
  sys.exit(0)
checks=d.get("checks") or []
for c in checks:
  if not c.get("ok"):
    cid=c.get("id","?")
    summ=c.get("summary","")
    print(f"- {cid}: {summ}".rstrip())
PY
}



is_our_pid() {
  local pid="$1"
  local cmd
  cmd="$(ps -p "$pid" -o command= 2>/dev/null || true)"
  [[ -z "${cmd:-}" ]] && return 1

  # Only consider processes started from our install dir.
  if echo "$cmd" | grep -Fq "$APP_DIR/app/services/local-orbit/src/index.ts"; then
    return 0
  fi
  if echo "$cmd" | grep -Fq "$APP_DIR/app/services/anchor/src/index.ts"; then
    return 0
  fi
  return 1
}

kill_owned_listeners() {
  # Kill existing Codex Pocket processes that are currently holding our ports.
  # We intentionally do NOT kill unrelated processes.
  if ! command -v lsof >/dev/null 2>&1; then
    return 0
  fi

  local aport
  aport="$(anchor_port 2>/dev/null || echo 8788)"

  for p in 8790 "$aport"; do
    local lpids
    lpids="$(lsof -nP -t -iTCP:"$p" -sTCP:LISTEN 2>/dev/null || true)"
    [[ -z "${lpids:-}" ]] && continue

    for pid in $lpids; do
      if is_our_pid "$pid"; then
        kill "$pid" >/dev/null 2>&1 || true
      fi
    done
  done

  # Give the OS a moment to release ports.
  sleep 0.1
}

port_conflicts() {
  # Return non-empty if our ports are in use by non-owned processes.
  if ! command -v lsof >/dev/null 2>&1; then
    return 0
  fi

  local aport
  aport="$(anchor_port 2>/dev/null || echo 8788)"

  local out=""
  for p in 8790 "$aport"; do
    local lpids
    lpids="$(lsof -nP -t -iTCP:"$p" -sTCP:LISTEN 2>/dev/null || true)"
    [[ -z "${lpids:-}" ]] && continue

    for pid in $lpids; do
      if ! is_our_pid "$pid"; then
        local cmd
        cmd="$(ps -p "$pid" -o command= 2>/dev/null || true)"
        out+="port $p is in use by pid $pid: $cmd"$'\n'
      fi
    done
  done

  echo "$out"
}

wait_healthy() {
  local base="$1"
  local i
  for i in $(seq 1 40); do
    if curl -fsS "$base/health" >/dev/null 2>&1; then
      return 0
    fi
    sleep 0.1
  done
  return 1
}
cmd_doctor() {
  echo "${bold}Dependencies${reset}"
  need_cmd git
  if ts="$(resolve_tailscale 2>/dev/null)"; then
    echo "tailscale: ok ($ts)"
  else
    echo "Missing dependency: tailscale" >&2
    echo "Install Tailscale first: https://tailscale.com/download" >&2
  fi
  if bunp="$(resolve_bun 2>/dev/null)"; then
    echo "bun: ok ($bunp)"
  else
    echo "bun: missing (install Bun: https://bun.sh)" >&2
  fi
  if command -v codex >/dev/null 2>&1; then
    echo "codex: ok"
  else
    echo "codex: missing (install if you want anchor to run)"
  fi

  echo ""
  echo "${bold}Service${reset}"
  read_config
  local base
  base="$(base_url)"
  if curl -fsS "$base/health" >/dev/null 2>&1; then
    echo "service: reachable at $base"
  else
    echo "service: not reachable at $base (try: codex-pocket start)"
  fi
}

cmd_token() {
  read_config
  token
}

cmd_urls() {
  read_config
  local base
  base="$(base_url)"
  local pub
  pub="$(public_origin)"
  echo "Local:    $base"
  echo "Admin:    $base/admin"
  if [[ -n "${pub:-}" ]]; then
    echo "Tailnet:  $pub/"
    echo "Tailnet Admin: $pub/admin"
  fi
}

cmd_diagnose() {
  read_config
  local base
  base="$(base_url)"
  local host port pub
  host="$(config_host)"
  port="$(config_port)"
  pub="$(public_origin)"

  echo "${bold}Codex Pocket Diagnose${reset}"
  echo "Home:   $APP_DIR"
  echo "Config: $CONFIG_JSON"
  echo "Base:   $base"
  [[ -n "${pub:-}" ]] && echo "Public: $pub"

  echo ""
  echo "${bold}Versions${reset}"
  if [[ -d "$APP_DIR/app/.git" ]]; then
    echo -n "app:    "
    git -C "$APP_DIR/app" rev-parse --short HEAD 2>/dev/null || echo "unknown"
  else
    echo "app:    not installed"
  fi
  if bunp="$(resolve_bun 2>/dev/null)"; then
    echo -n "bun:    "
    "$bunp" --version 2>/dev/null || echo "unknown"
  else
    echo "bun:    missing"
  fi
  if command -v codex >/dev/null 2>&1; then
    echo "codex:  ok"
  else
    echo "codex:  missing"
  fi

  echo ""
  echo "${bold}Service${reset}"
  if curl -fsS "$base/health" >/dev/null 2>&1; then
    echo "health: ok"
  else
    echo "health: FAILED (try: codex-pocket restart)"
  fi

  echo ""
  echo "${bold}Ports${reset}"
  if command -v lsof >/dev/null 2>&1; then
    lsof -nP -iTCP:"$port" -sTCP:LISTEN 2>/dev/null || echo "no listener on $port"
    local aport
    aport="$(anchor_port 2>/dev/null || echo 8788)"
    lsof -nP -iTCP:"$aport" -sTCP:LISTEN 2>/dev/null || echo "no listener on $aport"
  else
    echo "lsof: missing (install to get port diagnostics)"
  fi

  echo ""
  echo "${bold}Tailscale${reset}"
  if ts="$(resolve_tailscale 2>/dev/null)"; then
    echo "tailscale: $ts"
    "$ts" status 2>/dev/null | head -n 40 || true
    echo ""
    "$ts" serve status 2>/dev/null || true
  else
    echo "tailscale: missing"
  fi

  echo ""
  echo "${bold}Logs (tail)${reset}"
  if [[ -f "$APP_DIR/server.log" ]]; then
    echo "-- server.log --"
    tail -n 120 "$APP_DIR/server.log" || true
  fi
  if [[ -f "$APP_DIR/anchor.log" ]]; then
    echo "-- anchor.log --"
    tail -n 120 "$APP_DIR/anchor.log" || true
  fi
}

cmd_start() {
  read_config
  local plist="$HOME/Library/LaunchAgents/${LABEL}.plist"
  local bun_bin
  bun_bin="$(resolve_bun || true)"
  if [[ -z "${bun_bin:-}" ]]; then
    echo "bun is required to start the service." >&2
    exit 1
  fi

  # Ensure we don't pile up duplicate instances on restart/update.
  kill_owned_listeners >/dev/null 2>&1 || true
  local conflicts
  conflicts="$(port_conflicts || true)"
  if [[ -n "${conflicts:-}" ]]; then
    echo "Port conflict detected:" >&2
    echo "$conflicts" >&2
    echo "Resolve the conflict (or change ports) and try again." >&2
    exit 1
  fi

  if [[ ! -f "$plist" ]]; then
    echo "Missing launchd plist: $plist" >&2
    echo "Re-run installer." >&2
    exit 1
  fi

  start_bg() {
    rm -f "$PID_FILE" >/dev/null 2>&1 || true
    touch "$APP_DIR/server.log" >/dev/null 2>&1 || true
    local pub
    pub="$(public_origin)"
    local aport
    aport="$(anchor_port)"
    local host
    host="$(config_host)"
    local port
    port="$(config_port)"
    nohup env \
      ZANE_LOCAL_TOKEN="$(token)" \
      ZANE_LOCAL_CONFIG_JSON="$CONFIG_JSON" \
      ZANE_LOCAL_HOST="$host" \
      ZANE_LOCAL_PORT="$port" \
      ZANE_LOCAL_DB="$(db_path)" \
      ZANE_LOCAL_RETENTION_DAYS="$(retention_days)" \
      ZANE_LOCAL_PUBLIC_ORIGIN="$pub" \
      ZANE_LOCAL_UI_DIST_DIR="$APP_DIR/app/dist" \
      ZANE_LOCAL_ANCHOR_CWD="$APP_DIR/app/services/anchor" \
      ZANE_LOCAL_ANCHOR_LOG="$APP_DIR/anchor.log" \
      ANCHOR_HOST="127.0.0.1" \
      ANCHOR_PORT="$aport" \
      ZANE_LOCAL_ANCHOR_CMD="$bun_bin" \
      ZANE_LOCAL_AUTOSTART_ANCHOR="1" \
      "$bun_bin" run "$APP_DIR/app/services/local-orbit/src/index.ts" >>"$APP_DIR/server.log" 2>&1 </dev/null &
    disown >/dev/null 2>&1 || true
    echo $! >"$PID_FILE"
    echo "Started (background pid: $(cat "$PID_FILE"))"
    local base
    base="$(base_url)"
    echo "Waiting for service to become healthy..."
    if ! wait_healthy "$base"; then
      echo "Warning: service did not become healthy at $base/health" >&2
      echo "Check logs: $APP_DIR/server.log" >&2
    fi
    return 0
  }

  # Prefer launchd, but fall back to a PID-based background process if launchctl is blocked.
  launchctl unload "$plist" >/dev/null 2>&1 || true
  load_out="$(launchctl load "$plist" 2>&1)" || true
  if echo "$load_out" | grep -qi "Load failed: 5"; then
    echo "launchctl load failed (error 5). Starting in background instead (no auto-start on login)." >&2
    start_bg
    return 0
  fi

  if [[ -n "$load_out" ]]; then
    echo "$load_out" >&2
  fi
  echo "Started ($LABEL)"
  local base
  base="$(base_url)"
  echo "Waiting for service to become healthy..."
  if ! wait_healthy "$base"; then
    echo "launchd start did not become healthy; falling back to background start." >&2
    launchctl unload "$plist" >/dev/null 2>&1 || true
    start_bg
  fi
}

cmd_stop() {
  local plist="$HOME/Library/LaunchAgents/${LABEL}.plist"
  if [[ -f "$plist" ]]; then
    launchctl unload "$plist" >/dev/null 2>&1 || true
  fi

  if [[ -f "$PID_FILE" ]]; then
    local pid
    pid="$(cat "$PID_FILE" 2>/dev/null || true)"
    if [[ -n "$pid" ]]; then
      kill "$pid" >/dev/null 2>&1 || true
    fi
    rm -f "$PID_FILE" >/dev/null 2>&1 || true
  fi

  # Safety net: in environments where PID tracking fails (permissions/sandbox), kill by script path.
  pkill -f "$APP_DIR/app/services/local-orbit/src/index.ts" 2>/dev/null || true
  pkill -f "$APP_DIR/app/services/anchor/src/index.ts" 2>/dev/null || true

  # Final safety net: kill anything still listening on our configured ports.
  if command -v lsof >/dev/null 2>&1; then
    local aport
    aport="$(anchor_port 2>/dev/null || echo 8788)"
    for p in 8790 "$aport"; do
      while true; do
        local lpids
        lpids="$(lsof -nP -t -iTCP:"$p" -sTCP:LISTEN 2>/dev/null || true)"
        [[ -z "${lpids:-}" ]] && break
        # shellcheck disable=SC2086
        kill $lpids >/dev/null 2>&1 || true
        sleep 0.1
      done
    done
  fi
  echo "Stopped ($LABEL)"
}

cmd_status() {
  read_config
  local base
  base="$(base_url)"
  curl_auth "$base/admin/status"
}

cmd_logs() {
  read_config
  local svc="${1:-anchor}"
  local base
  base="$(base_url)"
  curl_auth "$base/admin/logs?service=$svc"
}

cmd_pair() {
  read_config
  local base
  base="$(base_url)"
  curl_auth "$base/admin/pair/new" -X POST -H 'content-type: application/json' -d '{}' | python3 - <<'PY'
import json,sys
d=json.load(sys.stdin)
print(d.get('pairUrl',''))
PY
}

cmd_ensure() {
  read_config
  local base
  base="$(base_url)"

  # If server isn't reachable, restart it.
  if ! curl -fsS "$base/health" >/dev/null 2>&1; then
    echo "Service not reachable; restarting..." >&2
    cmd_restart
  fi

  echo "Validating..."
  local code body
  local resp
  resp="$(curl_auth_soft_with_code "$base/admin/validate" 2>/dev/null || true)"
  CODE=""
  BODY=""
  printf '%s' "$resp" | split_code_body
  code="$CODE"
  body="$BODY"

  if [[ "$code" == "401" ]]; then
    echo "Validate failed: 401 Unauthorised" >&2
    echo "If /admin is asking for a token, run: codex-pocket token" >&2
    return 1
  fi
  if [[ -z "${body//[[:space:]]/}" ]]; then
    echo "Validate failed: empty response (HTTP $code)" >&2
    echo "Next: codex-pocket diagnose" >&2
    return 1
  fi
  if [[ "${body:0:1}" != "{" ]]; then
    echo "Validate returned non-JSON (HTTP $code). First 200 bytes:" >&2
    printf '%s\n' "${body:0:200}" >&2
    return 1
  fi
  if printf '%s' "$body" | json_ok; then
    echo "OK"
    return 0
  fi

  echo "Validate reported issues:" >&2
  printf '%s' "$body" | json_compact_failures >&2 || true

  echo "Repairing (safe actions)..." >&2
  curl_auth "$base/admin/repair" -X POST -H 'content-type: application/json' -d '{"actions":["ensureUploadDir","startAnchor","pruneUploads","fixTailscaleServe"]}' >/dev/null 2>&1 || true

  echo "Re-validating..."
  resp="$(curl_auth_soft_with_code "$base/admin/validate" 2>/dev/null || true)"
  CODE=""
  BODY=""
  printf '%s' "$resp" | split_code_body
  code="$CODE"
  body="$BODY"
  if [[ "$code" == "401" ]]; then
    echo "Re-validate failed: 401 Unauthorised" >&2
    return 1
  fi
  if [[ -z "${body//[[:space:]]/}" ]]; then
    echo "Re-validate failed: empty response (HTTP $code)" >&2
    return 1
  fi
  if [[ "${body:0:1}" != "{" ]]; then
    echo "Re-validate returned non-JSON (HTTP $code). First 200 bytes:" >&2
    printf '%s\n' "${body:0:200}" >&2
    return 1
  fi
  if printf '%s' "$body" | json_ok; then
    echo "OK"
    return 0
  fi
  echo "NOT OK" >&2
  printf '%s\n' "$body" | python3 -m json.tool 2>/dev/null || true
  return 1
}

cmd_smoke_test() {
  read_config
  local base
  base="$(base_url)"

  echo "Codex Pocket smoke test"
  echo "Base URL: $base"

  # 1) health
  if ! curl -fsS "$base/health" >/dev/null 2>&1; then
    echo "WARN: /health unreachable; attempting restart..." >&2
    cmd_restart || true
    if ! curl -fsS "$base/health" >/dev/null 2>&1; then
      echo "FAIL: /health unreachable" >&2
      echo "Next: codex-pocket diagnose" >&2
      return 1
    fi
  fi
  echo "PASS: /health"

  # 2) validate (requires token)
  local code body
  local resp
  resp="$(curl_auth_soft_with_code "$base/admin/validate" 2>/dev/null || true)"
  CODE=""
  BODY=""
  printf '%s' "$resp" | split_code_body
  code="$CODE"
  body="$BODY"
  if [[ "$code" == "401" ]]; then
    echo "FAIL: /admin/validate unauthorised (token mismatch?)" >&2
    echo "Run: codex-pocket token" >&2
    return 1
  fi
  if [[ -z "${body//[[:space:]]/}" ]]; then
    echo "FAIL: /admin/validate returned empty (HTTP $code)" >&2
    return 1
  fi
  if [[ "${body:0:1}" != "{" ]]; then
    echo "FAIL: /admin/validate returned non-JSON (HTTP $code):" >&2
    printf '%s\n' "${body:0:200}" >&2
    return 1
  fi
  if ! printf '%s' "$body" | json_ok; then
    echo "FAIL: /admin/validate reported issues" >&2
    printf '%s\n' "$body" | python3 -m json.tool 2>/dev/null || true
    echo "Try: codex-pocket ensure" >&2
    return 1
  fi
  echo "PASS: /admin/validate"

  # 3) status should return JSON
  if ! curl_auth "$base/admin/status" >/dev/null 2>&1; then
    echo "FAIL: /admin/status failed" >&2
    return 1
  fi
  echo "PASS: /admin/status"

  echo "OK"
}

cmd_summary() {
  read_config
  local base
  base="$(base_url)"
  echo ""
  echo "Summary"
  echo "Home dir:        $APP_DIR"
  echo "Config:          $CONFIG_JSON"
  echo "Local URL:       $base"
  echo "Admin URL:       $base/admin"
  local pub
  pub="$(public_origin)"
  echo "Tailnet URL:     ${pub:-}"
  echo "Tailnet Admin:   ${pub:+$pub/admin}"
  echo "Access Token:    $(cmd_token | head -c 8)..."
  echo "Logs:            $APP_DIR/server.log"
  echo "Anchor logs:     $APP_DIR/anchor.log"
  echo "Uploads:         $APP_DIR/uploads"
  echo "DB:              $(db_path)"
}

cmd_restart() {
  cmd_stop
  cmd_start
}

cmd_open_admin() {
  read_config
  local base
  base="$(base_url)"
  local url="$base/admin"
  if command -v open >/dev/null 2>&1; then
    open "$url" >/dev/null 2>&1 || true
  fi
  echo "$url"
}


cmd_update() {
  # Run update steps in a helper script so we never truncate/overwrite $0 while
  # Bash is still reading it (which causes "unexpected EOF").
  read_config

  local helper
  helper="$(mktemp -t codex-pocket-update.XXXXXX)"
  cat >"$helper" <<'SH'
#!/usr/bin/env bash
set -euo pipefail

APP_DIR="${CODEX_POCKET_HOME:-$HOME/.codex-pocket}"
CONFIG_JSON="$APP_DIR/config.json"
LABEL="com.codex.pocket"

need_cmd() { command -v "$1" >/dev/null 2>&1 || { echo "Missing dependency: $1" >&2; exit 1; }; }

resolve_bun() {
  if command -v bun >/dev/null 2>&1; then command -v bun; return 0; fi
  if [[ -x "$HOME/.bun/bin/bun" ]]; then echo "$HOME/.bun/bin/bun"; return 0; fi
  if [[ -x "/opt/homebrew/bin/bun" ]]; then echo "/opt/homebrew/bin/bun"; return 0; fi
  return 1
}

base_url() {
  python3 - "$CONFIG_JSON" <<'PY'
import json,sys
with open(sys.argv[1]) as f:
  d=json.load(f)
print(f"http://{d.get('host','127.0.0.1')}:{d.get('port',8790)}")
PY
}

cfg() {
  # Print a config key (top-level) or empty string if missing.
  local key="$1"
  python3 - "$CONFIG_JSON" "$key" <<'PY'
import json,sys
path=sys.argv[1]; key=sys.argv[2]
with open(path) as f:
  d=json.load(f)
v=d.get(key,"")
if v is None: v=""
print(v)
PY
}

cfg_anchor_port() {
  python3 - "$CONFIG_JSON" <<'PY'
import json,sys
with open(sys.argv[1]) as f:
  d=json.load(f)
aport=((d.get("anchor") or {}).get("port")) or 8788
print(aport)
PY
}

stop_service() {
  launchctl unload "$HOME/Library/LaunchAgents/${LABEL}.plist" >/dev/null 2>&1 || true
  pkill -f "$APP_DIR/app/services/local-orbit/src/index.ts" >/dev/null 2>&1 || true
  pkill -f "$APP_DIR/app/services/anchor/src/index.ts" >/dev/null 2>&1 || true
}

restart_via_cli() {
  local cli="$APP_DIR/bin/codex-pocket"
  local base
  base="$(base_url)"

  if [[ -x "$cli" ]]; then
    # Use the installed CLI's start logic (includes token/env + port conflict handling).
    "$cli" restart >/dev/null 2>&1 || true
  else
    # Last resort: run local-orbit with only config json.
    nohup env ZANE_LOCAL_CONFIG_JSON="$CONFIG_JSON" "$bun_bin" run "$APP_DIR/app/services/local-orbit/src/index.ts" >>"$APP_DIR/server.log" 2>&1 </dev/null &
  fi

  for _ in $(seq 1 50); do
    curl -fsS "$base/health" >/dev/null 2>&1 && return 0
    sleep 0.1
  done
  return 1
}

need_cmd git
need_cmd curl

bun_bin="$(resolve_bun || true)"
if [[ -z "${bun_bin:-}" ]]; then
  echo "bun is required to update." >&2
  exit 1
fi

repo_dir="$APP_DIR/app"
if [[ ! -d "$repo_dir/.git" ]]; then
  echo "Install not found at $repo_dir (missing .git)." >&2
  echo "Re-run the installer to set up the app." >&2
  exit 1
fi

old="$(git -C "$repo_dir" rev-parse --short HEAD 2>/dev/null || true)"

stop_service || true

if ! git -C "$repo_dir" diff --quiet 2>/dev/null; then
  echo "Local changes detected in $repo_dir; refusing to update." >&2
  exit 1
fi
if ! git -C "$repo_dir" diff --cached --quiet 2>/dev/null; then
  echo "Staged changes detected in $repo_dir; refusing to update." >&2
  exit 1
fi

echo "Updating Codex Pocket in $repo_dir"
git -C "$repo_dir" fetch --prune origin >/dev/null
git -C "$repo_dir" pull --ff-only origin main
new="$(git -C "$repo_dir" rev-parse --short HEAD 2>/dev/null || true)"

echo "Building UI"
(cd "$repo_dir" && "$bun_bin" install)
(cd "$repo_dir" && "$bun_bin" run build)

if [[ -f "$repo_dir/bin/codex-pocket" ]]; then
  mkdir -p "$APP_DIR/bin" >/dev/null 2>&1 || true
  cp "$repo_dir/bin/codex-pocket" "$APP_DIR/bin/codex-pocket.new" >/dev/null 2>&1 || true
  chmod +x "$APP_DIR/bin/codex-pocket.new" >/dev/null 2>&1 || true
  mv -f "$APP_DIR/bin/codex-pocket.new" "$APP_DIR/bin/codex-pocket" >/dev/null 2>&1 || true
fi

  if ! restart_via_cli; then
    echo "ERROR: service did not become healthy after update." >&2
    echo "Last 80 lines of server.log:" >&2
    tail -n 80 "$APP_DIR/server.log" >&2 || true
    exit 1
  fi
  echo "Updated ${old:-?} -> ${new:-?}"
SH
  chmod +x "$helper" >/dev/null 2>&1 || true
  bash "$helper"

  echo ""
  echo "Running ensure..."
  cmd_ensure
  echo ""
  cmd_summary || true
  echo ""
  echo "Running smoke-test..."
  cmd_smoke_test
}

main() {
  local cmd="${1:-}"
  case "$cmd" in
    doctor) shift; cmd_doctor "$@";;
    start) shift; cmd_start "$@";;
    stop) shift; cmd_stop "$@";;
    restart) shift; cmd_restart "$@";;
    ensure) shift; cmd_ensure "$@";;
    smoke-test) shift; cmd_smoke_test "$@";;
    summary) shift; cmd_summary "$@";;
    status) shift; cmd_status "$@";;
    logs) shift; cmd_logs "$@";;
    pair) shift; cmd_pair "$@";;
    token) shift; cmd_token "$@";;
    urls) shift; cmd_urls "$@";;
    diagnose) shift; cmd_diagnose "$@";;
    open-admin) shift; cmd_open_admin "$@";;
    update) shift; cmd_update "$@";;
    -h|--help|help|"") usage;;
    *) echo "Unknown command: $cmd" >&2; usage; exit 1;;
  esac
}

main "$@"
