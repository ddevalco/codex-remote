#!/usr/bin/env bash
set -euo pipefail

# codex-pocket CLI
#
# This CLI manages the local Codex Pocket service (launchd) and calls its admin API.

APP_DIR="${CODEX_POCKET_HOME:-$HOME/.codex-pocket}"
CONFIG_JSON="$APP_DIR/config.json"
LABEL="com.codex.pocket"
PID_FILE="$APP_DIR/server.pid"

bold=$'\033[1m'
reset=$'\033[0m'

usage() {
  cat <<USAGE
Usage: codex-pocket <command>

Commands:
  doctor                 Check dependencies and service health
  start                  Start the launchd service
  stop                   Stop the launchd service
  restart                Restart the service
  status                 Show admin status JSON
  logs [anchor]          Tail logs (default: anchor)
  pair                   Create a one-time pairing link (prints URL)
  open-admin             Open the local Admin page in your browser
  update                 Update the installed app (git pull, rebuild, restart)

Environment:
  CODEX_POCKET_HOME       Defaults to ~/.codex-pocket
USAGE
}

need_cmd() {
  command -v "$1" >/dev/null 2>&1 || { echo "Missing dependency: $1" >&2; exit 1; }
}

resolve_tailscale() {
  if command -v tailscale >/dev/null 2>&1; then
    command -v tailscale
    return 0
  fi
  # Tailscale's macOS GUI app bundles a CLI at this path.
  if [[ -x "/Applications/Tailscale.app/Contents/MacOS/Tailscale" ]]; then
    echo "/Applications/Tailscale.app/Contents/MacOS/Tailscale"
    return 0
  fi
  if [[ -x "/opt/homebrew/bin/tailscale" ]]; then
    echo "/opt/homebrew/bin/tailscale"
    return 0
  fi
  if [[ -x "/usr/local/bin/tailscale" ]]; then
    echo "/usr/local/bin/tailscale"
    return 0
  fi
  return 1
}

resolve_bun() {
  if command -v bun >/dev/null 2>&1; then
    command -v bun
    return 0
  fi
  if [[ -x "$HOME/.bun/bin/bun" ]]; then
    echo "$HOME/.bun/bin/bun"
    return 0
  fi
  if [[ -x "/opt/homebrew/bin/bun" ]]; then
    echo "/opt/homebrew/bin/bun"
    return 0
  fi
  return 1
}

read_config() {
  [[ -f "$CONFIG_JSON" ]] || { echo "Missing config: $CONFIG_JSON" >&2; exit 1; }
}

base_url() {
  python3 - "$CONFIG_JSON" <<'PY'
import json,sys
with open(sys.argv[1]) as f:
  d=json.load(f)
print(f"http://{d.get('host','127.0.0.1')}:{d.get('port',8790)}")
PY
}

token() {
  python3 - "$CONFIG_JSON" <<'PY'
import json,sys
with open(sys.argv[1]) as f:
  d=json.load(f)
print(d.get('token',''))
PY
}

public_origin() {
  python3 - "$CONFIG_JSON" <<'PY'
import json,sys
with open(sys.argv[1]) as f:
  d=json.load(f)
print(d.get('publicOrigin',''))
PY
}

anchor_port() {
  python3 - "$CONFIG_JSON" <<'PY'
import json,sys
with open(sys.argv[1]) as f:
  d=json.load(f)
print(((d.get("anchor") or {}).get("port")) or 8788)
PY
}

db_path() {
  python3 - "$CONFIG_JSON" <<'PY'
import json,sys
with open(sys.argv[1]) as f:
  d=json.load(f)
print(d.get("db",""))
PY
}

retention_days() {
  python3 - "$CONFIG_JSON" <<'PY'
import json,sys
with open(sys.argv[1]) as f:
  d=json.load(f)
print(d.get("retentionDays",14))
PY
}

curl_auth() {
  local url="$1"; shift
  local tok
  tok="$(token)"
  curl -fsS -H "Authorization: Bearer $tok" "$url" "$@"
}



is_our_pid() {
  local pid="$1"
  local cmd
  cmd="$(ps -p "$pid" -o command= 2>/dev/null || true)"
  [[ -z "${cmd:-}" ]] && return 1

  # Only consider processes started from our install dir.
  if echo "$cmd" | grep -Fq "$APP_DIR/app/services/local-orbit/src/index.ts"; then
    return 0
  fi
  if echo "$cmd" | grep -Fq "$APP_DIR/app/services/anchor/src/index.ts"; then
    return 0
  fi
  return 1
}

kill_owned_listeners() {
  # Kill existing Codex Pocket processes that are currently holding our ports.
  # We intentionally do NOT kill unrelated processes.
  if ! command -v lsof >/dev/null 2>&1; then
    return 0
  fi

  local aport
  aport="$(anchor_port 2>/dev/null || echo 8788)"

  for p in 8790 "$aport"; do
    local lpids
    lpids="$(lsof -nP -t -iTCP:"$p" -sTCP:LISTEN 2>/dev/null || true)"
    [[ -z "${lpids:-}" ]] && continue

    for pid in $lpids; do
      if is_our_pid "$pid"; then
        kill "$pid" >/dev/null 2>&1 || true
      fi
    done
  done

  # Give the OS a moment to release ports.
  sleep 0.1
}

port_conflicts() {
  # Return non-empty if our ports are in use by non-owned processes.
  if ! command -v lsof >/dev/null 2>&1; then
    return 0
  fi

  local aport
  aport="$(anchor_port 2>/dev/null || echo 8788)"

  local out=""
  for p in 8790 "$aport"; do
    local lpids
    lpids="$(lsof -nP -t -iTCP:"$p" -sTCP:LISTEN 2>/dev/null || true)"
    [[ -z "${lpids:-}" ]] && continue

    for pid in $lpids; do
      if ! is_our_pid "$pid"; then
        local cmd
        cmd="$(ps -p "$pid" -o command= 2>/dev/null || true)"
        out+="port $p is in use by pid $pid: $cmd"$'\n'
      fi
    done
  done

  echo "$out"
}

wait_healthy() {
  local base="$1"
  local i
  for i in $(seq 1 40); do
    if curl -fsS "$base/health" >/dev/null 2>&1; then
      return 0
    fi
    sleep 0.1
  done
  return 1
}
cmd_doctor() {
  echo "${bold}Dependencies${reset}"
  need_cmd git
  if ts="$(resolve_tailscale 2>/dev/null)"; then
    echo "tailscale: ok ($ts)"
  else
    echo "Missing dependency: tailscale" >&2
    echo "Install Tailscale first: https://tailscale.com/download" >&2
  fi
  if bunp="$(resolve_bun 2>/dev/null)"; then
    echo "bun: ok ($bunp)"
  else
    echo "bun: missing (install Bun: https://bun.sh)" >&2
  fi
  if command -v codex >/dev/null 2>&1; then
    echo "codex: ok"
  else
    echo "codex: missing (install if you want anchor to run)"
  fi

  echo ""
  echo "${bold}Service${reset}"
  read_config
  local base
  base="$(base_url)"
  if curl -fsS "$base/health" >/dev/null 2>&1; then
    echo "service: reachable at $base"
  else
    echo "service: not reachable at $base (try: codex-pocket start)"
  fi
}

cmd_start() {
  read_config
  local plist="$HOME/Library/LaunchAgents/${LABEL}.plist"
  local bun_bin
  bun_bin="$(resolve_bun || true)"
  if [[ -z "${bun_bin:-}" ]]; then
    echo "bun is required to start the service." >&2
    exit 1
  fi

  # Ensure we don't pile up duplicate instances on restart/update.
  kill_owned_listeners >/dev/null 2>&1 || true
  local conflicts
  conflicts="$(port_conflicts || true)"
  if [[ -n "${conflicts:-}" ]]; then
    echo "Port conflict detected:" >&2
    echo "$conflicts" >&2
    echo "Resolve the conflict (or change ports) and try again." >&2
    exit 1
  fi

  if [[ ! -f "$plist" ]]; then
    echo "Missing launchd plist: $plist" >&2
    echo "Re-run installer." >&2
    exit 1
  fi

  # Prefer launchd, but fall back to a PID-based background process if launchctl is blocked.
  launchctl unload "$plist" >/dev/null 2>&1 || true
  load_out="$(launchctl load "$plist" 2>&1)" || true
  if echo "$load_out" | grep -qi "Load failed: 5"; then
    echo "launchctl load failed (error 5). Starting in background instead (no auto-start on login)." >&2
    rm -f "$PID_FILE" >/dev/null 2>&1 || true
    touch "$APP_DIR/server.log" >/dev/null 2>&1 || true
    local pub
    pub="$(public_origin)"
    local aport
    aport="$(anchor_port)"
    nohup env \
      ZANE_LOCAL_TOKEN="$(token)" \
      ZANE_LOCAL_CONFIG_JSON="$CONFIG_JSON" \
      ZANE_LOCAL_HOST="127.0.0.1" \
      ZANE_LOCAL_PORT="8790" \
      ZANE_LOCAL_DB="$(db_path)" \
      ZANE_LOCAL_RETENTION_DAYS="$(retention_days)" \
      ZANE_LOCAL_PUBLIC_ORIGIN="$pub" \
      ZANE_LOCAL_UI_DIST_DIR="$APP_DIR/app/dist" \
      ZANE_LOCAL_ANCHOR_CWD="$APP_DIR/app/services/anchor" \
      ZANE_LOCAL_ANCHOR_LOG="$APP_DIR/anchor.log" \
      ANCHOR_HOST="127.0.0.1" \
      ANCHOR_PORT="$aport" \
      ZANE_LOCAL_ANCHOR_CMD="$bun_bin" \
      ZANE_LOCAL_AUTOSTART_ANCHOR="1" \
      "$bun_bin" run "$APP_DIR/app/services/local-orbit/src/index.ts" >>"$APP_DIR/server.log" 2>&1 &
    echo $! >"$PID_FILE"
    echo "Started (background pid: $(cat "$PID_FILE"))"
    local base
    base="$(base_url)"
    echo "Waiting for service to become healthy..."
    if ! wait_healthy "$base"; then
      echo "Warning: service did not become healthy at $base/health" >&2
      echo "Check logs: $APP_DIR/server.log" >&2
    fi
    return 0
  fi

  if [[ -n "$load_out" ]]; then
    echo "$load_out" >&2
  fi
  echo "Started ($LABEL)"
  local base
  base="$(base_url)"
  echo "Waiting for service to become healthy..."
  if ! wait_healthy "$base"; then
    echo "Warning: service did not become healthy at $base/health" >&2
    echo "Check logs: $APP_DIR/server.log" >&2
  fi
}

cmd_stop() {
  local plist="$HOME/Library/LaunchAgents/${LABEL}.plist"
  if [[ -f "$plist" ]]; then
    launchctl unload "$plist" >/dev/null 2>&1 || true
  fi

  if [[ -f "$PID_FILE" ]]; then
    local pid
    pid="$(cat "$PID_FILE" 2>/dev/null || true)"
    if [[ -n "$pid" ]]; then
      kill "$pid" >/dev/null 2>&1 || true
    fi
    rm -f "$PID_FILE" >/dev/null 2>&1 || true
  fi

  # Safety net: in environments where PID tracking fails (permissions/sandbox), kill by script path.
  pkill -f "$APP_DIR/app/services/local-orbit/src/index.ts" 2>/dev/null || true
  pkill -f "$APP_DIR/app/services/anchor/src/index.ts" 2>/dev/null || true

  # Final safety net: kill anything still listening on our configured ports.
  if command -v lsof >/dev/null 2>&1; then
    local aport
    aport="$(anchor_port 2>/dev/null || echo 8788)"
    for p in 8790 "$aport"; do
      while true; do
        local lpids
        lpids="$(lsof -nP -t -iTCP:"$p" -sTCP:LISTEN 2>/dev/null || true)"
        [[ -z "${lpids:-}" ]] && break
        # shellcheck disable=SC2086
        kill $lpids >/dev/null 2>&1 || true
        sleep 0.1
      done
    done
  fi
  echo "Stopped ($LABEL)"
}

cmd_status() {
  read_config
  local base
  base="$(base_url)"
  curl_auth "$base/admin/status"
}

cmd_logs() {
  read_config
  local svc="${1:-anchor}"
  local base
  base="$(base_url)"
  curl_auth "$base/admin/logs?service=$svc"
}

cmd_pair() {
  read_config
  local base
  base="$(base_url)"
  curl_auth "$base/admin/pair/new" -X POST -H 'content-type: application/json' -d '{}' | python3 - <<'PY'
import json,sys
d=json.load(sys.stdin)
print(d.get('pairUrl',''))
PY
}

cmd_restart() {
  cmd_stop
  cmd_start
}

cmd_open_admin() {
  read_config
  local base
  base="$(base_url)"
  local url="$base/admin"
  if command -v open >/dev/null 2>&1; then
    open "$url" >/dev/null 2>&1 || true
  fi
  echo "$url"
}


cmd_update() {
  read_config
  need_cmd git

  local bun_bin
  bun_bin="$(resolve_bun || true)"
  if [[ -z "${bun_bin:-}" ]]; then
    echo "bun is required to update." >&2
    exit 1
  fi

  local repo_dir="$APP_DIR/app"
  if [[ ! -d "$repo_dir/.git" ]]; then
    echo "Install not found at $repo_dir (missing .git)." >&2
    echo "Re-run the installer to set up the app." >&2
    exit 1
  fi

  local old
  old="$(git -C "$repo_dir" rev-parse --short HEAD 2>/dev/null || true)"

  # Stop first to avoid file locks and port conflicts.
  cmd_stop >/dev/null 2>&1 || true

  # Refuse to update if the repo has local modifications.
  if ! git -C "$repo_dir" diff --quiet 2>/dev/null; then
    echo "Local changes detected in $repo_dir; refusing to update." >&2
    echo "Commit/stash your changes or reinstall cleanly." >&2
    exit 1
  fi
  if ! git -C "$repo_dir" diff --cached --quiet 2>/dev/null; then
    echo "Staged changes detected in $repo_dir; refusing to update." >&2
    echo "Commit/stash your changes or reinstall cleanly." >&2
    exit 1
  fi

  echo "Updating Codex Pocket in $repo_dir"
  git -C "$repo_dir" fetch --prune origin >/dev/null
  git -C "$repo_dir" pull --ff-only origin main

  local new
  new="$(git -C "$repo_dir" rev-parse --short HEAD 2>/dev/null || true)"

  echo "Building UI"
  (cd "$repo_dir" && "$bun_bin" install)
  (cd "$repo_dir" && "$bun_bin" run build)

  # Self-update the CLI if possible.
  if [[ -f "$repo_dir/bin/codex-pocket" ]]; then
    mkdir -p "$APP_DIR/bin" >/dev/null 2>&1 || true
    cp "$repo_dir/bin/codex-pocket" "$APP_DIR/bin/codex-pocket" >/dev/null 2>&1 || true
    chmod +x "$APP_DIR/bin/codex-pocket" >/dev/null 2>&1 || true
  fi

  # Start and verify health before returning.
  cmd_start
  echo "Updated ${old:-?} -> ${new:-?}"
}

main() {
  local cmd="${1:-}"
  case "$cmd" in
    doctor) shift; cmd_doctor "$@";;
    start) shift; cmd_start "$@";;
    stop) shift; cmd_stop "$@";;
    restart) shift; cmd_restart "$@";;
    status) shift; cmd_status "$@";;
    logs) shift; cmd_logs "$@";;
    pair) shift; cmd_pair "$@";;
    open-admin) shift; cmd_open_admin "$@";;
    update) shift; cmd_update "$@";;
    -h|--help|help|"") usage;;
    *) echo "Unknown command: $cmd" >&2; usage; exit 1;;
  esac
}

main "$@"
